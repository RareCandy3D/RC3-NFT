The dApp functions are used as follows:

--------------------------------------------------------------------------------------------------------------------------------------------------------------
RC3_721_Factory and RC3_1155_Factory contracts:


function create721NFT(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        uint96 _royalty


function create1155NFT(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        uint96 _royalty

Params: you need to pass in the name, symbol, uri (with / at the end), and royalty (where 1% = 100, and 10% == 1000)


These 2 functions appear in RC3_721_Factory and RC3_1155_Factory contracts respectively. 
It will be called when a user tries to deploy a new nft smart contract for their project.
A fee will be charged from them in ETH.
this fee can be found from the public method "fee"

--------------------------------------------------------------------------------------------------------------------------------------------------------------
RC3_Originals contract


function setRoyaltyInfo(uint256 _tokenId, address payable _receiver): can be called by the creator of tokenId to set royalty recipient

function royaltyInfo(uint256 _tokenId, uint256 _salePrice): returns the royalty address, as well as the royalty fee 

function mint(
        string memory _tokenURI,
        address payable creator,
        bytes32 category,
        bytes32 nature
    ):

This function mints a new token id. 
Note that the category and nature must be present in the "categories" and "natures" return values 

function setMarket(address market, bool isMarket): Used to set or remove a contract address from being recorgnized as whitelisted
function getInfo(uint256 tokenId): returns an array of info for a tokn id. this includes the
i. creator's address
ii. nature in bytes32
iii. category in bytes32

categories: returns an array of bytes32 which represents the individual categories created on the contract
natures: returns an array of bytes32 with length 3 (physical, digital & phygital) which represents the individual natures creatable in the contract

--------------------------------------------------------------------------------------------------------------------------------------------------------------

RC3_Creators contract


function createCategory(bytes32 category): allows users to create a new category in the contract. You must pass in the bytes32 of the string inputted by the user. To generate the bytes32 of a string, you need to call the following function:

function stringToBytes32(string memory source)

function canCreatePhysical(address creator): returns true or false if "creator" is able to create a physical or phygital nature NFT.

function createToken(
        address _initialHodler,         // can be the zero address if _initialSupply is 0, else, must be a valid address
        uint256 _initialSupply,         // initial supply to be minted        
        uint256 _maxSupply,             // max supply that can ever exist on this collection
        uint256 royalty,                // royalty on this collection 1% = 100. max is 50% ~ 5000
        bytes32 category,               // check "categories" for valid category
        bytes32 nature,                 // check "natures" for valid category
        string memory _uri              // can be an empty string or website url. Must end with /
    ) external returns (uint256 tokenId):        // token id of the newly created collection
This function creates a new NFT collection.

function mint(
        address to,                     
        uint256 id,
        uint256 amount
    ) external returns (bool success):
mints tokens

function mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts
    ) external returns (bool success):
mints tokens in batch. sender must have minting rights in all the ids

function setMinter(
        uint256 id,
        address minter,
        bool _canMint
    ) external: 

enables the creator of token id to set wallets that can mint on the id

function setRoyaltyInfo(
        address payable creator_,               // creators address
        address payable[] memory recipients,    // array of addresses which have shares in the royalty of this token id
        uint256[] memory shares,                // array of shares with index representing recipients index. Must total 1000 (1% = 10 shares)
        uint256 id,                             // token id
        uint256 royalty                         // royalty on this collection 1% = 100. max is 50% ~ 5000  
    ):

This function enables the creator of this token id the means to set split royatlies on who is entitled for shares in this id

function creator(uint256 _id) public view returns (address creator_): returns the creators address for token id _id

function exists(uint256 _id) external view returns (bool): returns true if _id exists in the contract

function getInfo(uint256 _id) external view returns (Info memory info): returns an array of info for a token _id. this includes the
i. creator's address
ii. nature in bytes32
iii. category in bytes32
iv. supply of _id
v. max supply of _id
vi. royalty of _id
v. custom URI string if any

function tokenSupply(uint256 _id) external returns (uint256 tokenSupply_): returns the supply of token id _id

function uri(uint256 id) public view override returns (string memory): returns the URI of token id

--------------------------------------------------------------------------------------------------------------------------------------------------------------